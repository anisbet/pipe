#!/bin/bash
#################################################################################
#
# Product: test-pipeline.sh
# Purpose: Can do serveral jobs related to testing a command line scripts and 
#          and other API.
#          1) Given spec-*.test files, can generate executeable test-*.sh files.
#          2) Given a markdown file, can generate spec-*.test files.
#          3) Can run all tests and log results.
#
# Copyright (c) Andrew Nisbet 2022 - 2024.
# All code covered by the project's license.
#
################################################################################

### Global variables
CLOBBER_EXISTING_FILES=false
GENERATE_MAKEFILE=false
GENERATE_TESTS=false
WORKING_DIR=.
TEST_MARKDOWN=''
GEN_SPEC=$WORKING_DIR/gen_spec.sh
GEN_TEST=$WORKING_DIR/gen_test.sh
MAKE_FILE=$WORKING_DIR/Makefile
# Added --run
VERSION="1.1.00"

### Functions
# Prints out usage message.
usage()
{
    cat << EOFU!
 Usage: $0 [flags]
Can do serveral jobs related to testing a command line scripts and other API.
  1) Given spec-*.test files, can generate executeable test-*.sh files.
  2) Given a markdown file, can generate spec-*.test files.
  3) Can run all tests and log results.

Flags:

-f, -force, --force: Over write any existing specs or test scripts.
-h, -help, --help: This help message.
-m, -make, --make: Create a Makefile for testing.
-r, -run, --run: Run all (any) pre-compiled tests.
-s, -spec_markdown, --spec_markdown={/foo/bar/readme.md}: Specifies the markdown
  file used to generate spec-*.test files, and generates the spec-*.test files.
  in the working directory. (See -w to set working directory).
-t, -test, --test: Generate test scripts. Searches for given spec-*.test 
  files and converts them into executable test-*.sh scripts.
-v, -version, --version: Print application version and exits.
-w, -working_dir, --working_dir{/foo/bar}: Sets the working directory for
  searching and writing any files. Default the current directory.
  Note that pipeline.sh will look for helper awk files in the working directory.

 Example:
    ${0} --flag=t
EOFU!
}

# Parses markdown into master specification file.
# Markdown file must exist.
genSpecs()
{
    [[ -x "$GEN_SPEC" ]] || { echo "**error required helper '$GEN_SPEC' not executable, exiting."; exit 1; }
    if [ "$CLOBBER_EXISTING_FILES" == true ]; then
        $GEN_SPEC --force --markdown="$TEST_MARKDOWN"
    else
        $GEN_SPEC --markdown="$TEST_MARKDOWN"
    fi
}

# Generates test scripts from any spec-*.test files.
genTests()
{
    local tmp=''
    tmp=/tmp/$(basename -s .sh "$0").tmp
    if find . -name spec-\*.test >"$tmp"; then
        while IFS= read -r line
        do
            # echo "DEBUG: $GEN_TEST --force --spec-file='$line'"
            if [ "$CLOBBER_EXISTING_FILES" == true ]; then
                $GEN_TEST --force --spec-file="$line"
            else
                $GEN_TEST --spec-file="$line"
            fi
        done <"$tmp"
        rm "$tmp"
        echo "done"
    else
        echo "no spec files to compile."
    fi
}

# Generate Makefile of tests.
genMakefile()
{
    local markdown="$1"
    cat >$MAKE_FILE <<EOMAKE!
# Makefile automatically generated by $(basename -s .sh $0).
# Copyright (c) Andrew Nisbet 2022.
# 
.PHONY: test clean pristine all

test: clean
	-./test-g.sh
	-./test-X.sh
	-./test-e.sh
	-./test-Z.sh
	-./test-2.sh
	-./test-x.sh
	-./test-s.sh
	-./test-H.sh
	-./test-G.sh
	-./test-n.sh
	-./test-7.sh
	-./test-b.sh
	-./test-8.sh
	-./test-T.sh
	-./test-D.sh
	-./test-U.sh
	-./test-6.sh
	-./test-w.sh
	-./test-Y.sh
	-./test-m.sh
	-./test-u.sh
	-./test-i.sh
	-./test-1.sh
	-./test-4.sh
	-./test-j.sh
	-./test-Q.sh
	-./test-v.sh
	-./test-N.sh
	-./test-O.sh
	-./test-K.sh
	-./test-B.sh
	-./test-z.sh
	-./test-r.sh
	-./test-d.sh
	-./test-F.sh
	-./test-o.sh
	-./test-P.sh
	-./test-V.sh
	-./test-\?.sh
	-./test-c.sh
	-./test-f.sh
	-./test-J.sh
	-./test-y.sh
	-./test-3.sh
	-./test-t.sh
	-./test-R.sh
	-./test-h.sh
	-./test-A.sh
	-./test-a.sh
	-./test-I.sh
	-./test-k.sh
	-./test-5.sh
	-./test-p.sh
	-./test-l.sh
	-./test-C.sh
	-./test-L.sh
	-./test-E.sh
	-./test-S.sh
	-./test-0.sh
	-./test-M.sh
	-./test-q.sh
	-./test-W.sh

clean:
	-rm ./*.log

build:
	./pipeline.sh -s $markdown --force --test

all: pristine
	make build
	./pipeline.sh --run

pristine: clean
	-rm ./spec-*
	-rm ./test-*

# EOF
EOMAKE!
    echo "make file created."
}

# Runs any tests already generated.
# Checks for a log file first and if there is one issues an alert.
runTests()
{
    local log=./pipe-tests.log
    if [ -s "$log" ]; then
        if grep FAIL "$log" >/dev/null 2>&1; then
            echo "*WARNING There is a pre-existing log file with errors."
            echo "*WARNING It has to be removed before starting tests."
            echo "Do you want to remove $log? (y/n) "
            while IFS= read -r answer; do
                # Check the user's response
                if [ "$answer" = "y" ]; then
                    # Remove the file
                    rm "$log"
                    echo "File $log has been removed."
                    break
                elif [ "$answer" = "n" ]; then
                    echo "File removal and therefore tests have been canceled."
                    break
                else
                    echo "Invalid response. Please enter 'y' for yes or 'n' for no."
                fi
            done
        fi
    fi
    for file in test-*; do
        if [ -x "$file" ]; then
            ./"$file"
        fi
    done
    if ! grep FAIL "$log"; then
        echo -e "\n#################\nAll tests passed!\n#################\n"
    else
        echo -e "\nOops test failure.\n\nSee '$log', line number(s):\n$(grep --line-number FAIL $log)"
    fi
}


### Parameter handling
### Check input parameters.
# $@ is all command line parameters passed to the script.
# -o is for short options like -v
# -l is for long options with double dash like --version
# the comma separates different long options
# -a is for long options with single dash like -version
options=$(getopt -l "force,help,make,run,spec_markdown:,test,version,working_dir" -o "fhmrs:tvw:" -a -- "$@")
if [ $? != 0 ] ; then echo "Failed to parse options...exiting." >&2 ; exit 1 ; fi
# set --:
# If no arguments follow this option, then the positional parameters are unset. Otherwise, the positional parameters
# are set to the arguments, even if some of them begin with a ‘-’.
eval set -- "$options"

while true
do
    case $1 in
    -f|--force)
        # Force the existing test-*.sh to be over-written.
        CLOBBER_EXISTING_FILES=true
        ;;
    
    -h|--help)
        usage
        exit 0
        ;;
    
    -m|--make)
        # Generate a Makefile in working_dir
        GENERATE_MAKEFILE=true
        ;;

    -r|--run)
        # Run any existing test files.
        runTests
        exit 0
        ;;

    -s|--spec_markdown)
        # /foo/bar/readme.md or similar.
        shift
        TEST_MARKDOWN="$1"
        ;;

    -t|--test)
        # Generate test files from any spec-*.test files.
        GENERATE_TESTS=true
        ;;

    -v|--version)
        echo "$0 version: $VERSION"
        exit 0
        ;;

    -w|--working_dir)
        # /foo/bar/readme.md or similar.
        shift
        export WORKING_DIR="$1"
        ;;

    --)
        shift
        break
        ;;
    esac
    shift
done
# Test for required -a api to test.
# : ${TEST_API:?Missing -a,--api}
: "${TEST_MARKDOWN:=../Readme.md}"
# [[ -x "$TEST_API" ]] || { echo "**error, '$TEST_API' is not executable, exiting."; exit 1; }
[[ -d "$WORKING_DIR" ]] || { echo "**error, invalid working directory: '$WORKING_DIR', exiting."; exit 1; }
cd "$WORKING_DIR" || exit 1
[[ -z "$TEST_MARKDOWN" ]] || genSpecs
[[ "$GENERATE_TESTS" == true ]] && genTests
[[ "$GENERATE_MAKEFILE" == true ]] && genMakefile "$TEST_MARKDOWN"
exit 0
# EOF
